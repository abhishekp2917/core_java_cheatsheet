*   Explain multithreading in Java in detail.

>>  Multithreading is a process of executing multiple threads concurrently within a 
    single process to achieve parallelism. It allows a program to perform multiple tasks 
    simultaneously, improving performance and responsiveness.

    In Java, multithreading is a built-in feature that enables developers to create and 
    manage threads efficiently.

_______________________________________________________________________________________

*   What are the differences between process and thread ?

>>  (1) Definition:

        - Process is an independent program with its own memory and system resources.

        - Thread is a lightweight execution unit within a process that shares its resources.

    (2) Resource Allocation:

        - Process has its own memory space, file handles, and system resources.

        - Thread shares memory and resources of the parent process.

    (3) Creation Overhead:

        - Process creation is slow as it requires allocating separate resources and memory.

        - Thread creation is faster since it shares existing resources of the process.

    (4) Context Switching:

        - Process context switching is expensive as it involves switching memory spaces.

        - Thread context switching is faster as threads share the same address space.

    (5) Isolation:

        - Process are completely isolated from other processes; one process does not 
          affect another.

        - Thread are not isolated; a faulty thread can impact other threads in the 
          same process.

    (6) Example:

        - Process: Running multiple instances of a web browser (Chrome, Firefox).

        - Thread: Multiple browser tabs running within the same browser process.

_______________________________________________________________________________________

*   What are various ways to create a Thread ?

>>  (1) Extending Thread Class:

        - Create a class that extends Thread and override the run() method.

        - Simple to use but prevents extending other classes due to single inheritance.

        Example:    

            MyThread.class:

                ```
                    class MyThread extends Thread {
                        public void run() {
                            System.out.println("Thread is running...");
                        }
                    }
                ```

            Main.class:
                
                ```
                    public class Main {
                        public static void main(String[] args) {
                            MyThread t1 = new MyThread();
                            t1.start();  // Starts the thread
                        }
                    }
                ```

    (2) Implementing Runnable Interface:

        - Create a class that implements Runnable and override the run() method.

        - Create a Thread object and pass an instance of this Runnable implementation 
          class to it via Constructor.

        - Preferred approach as it allows multiple inheritance.

        Example:

            MyRunnable.class:

                ```
                    class MyRunnable implements Runnable {
                        public void run() {
                            System.out.println("Thread is running...");
                        }
                    }
                ```

            Main.class:

                ```
                    public class Main {
                        public static void main(String[] args) {
                            Thread t1 = new Thread(new MyRunnable());
                            t1.start();
                        }
                    }
                ```

    (3) Using Thread with Anonymous Class:

        - Directly create a Thread object and override run() using an anonymous class.

        - Useful for short-lived threads without needing a separate class.

        Example:

            Main.class:

                ```
                    public class Main {
                        public static void main(String[] args) {
                            Thread t1 = new Thread() {
                                public void run() {
                                    System.out.println("Thread is running...");
                                }
                            };
                            t1.start();
                        }
                    }
                ```

    (4) Using Runnable with Anonymous Class:

        - Pass an anonymous Runnable implementation to a Thread object.

        Example:

            Main.class:

                ```
                    public class Main {
                        public static void main(String[] args) {
                            Thread t1 = new Thread(new Runnable() {
                                public void run() {
                                    System.out.println("Thread is running...");
                                }
                            });
                            t1.start();
                        }
                    }
                ```

    (5) Using Lambda Expression (Java 8+):

        - Instead of an anonymous class, use a lambda expression to simplify Runnable.

        Example:

            Main.class:

                ```
                    public class Main {
                        public static void main(String[] args) {
                            Thread t1 = new Thread(() -> System.out.println("Thread is running..."));
                            t1.start();
                        }
                    }
                ```

    (6) Using Callable and FutureTask (For Returning Values):

        - Callable<T> can return a result and throw exceptions.

        - Use FutureTask to handle execution.

        - Useful when you need to return a result from a thread.

        Example:

            ```
                import java.util.concurrent.Callable;
                import java.util.concurrent.FutureTask;

                public class Main {
                    public static void main(String[] args) throws Exception {
                        Callable<Integer> callable = () -> {
                            System.out.println("Thread is running...");
                            return 10;
                        };

                        FutureTask<Integer> futureTask = new FutureTask<>(callable);
                        Thread t1 = new Thread(futureTask);
                        t1.start();

                        // Get result after execution
                        System.out.println("Result: " + futureTask.get());
                    }
                }
            ```

    (7) Using ExecutorService (Thread Pool):

        - ExecutorService manages a pool of threads.

        - Submit tasks instead of manually creating threads.
        
        - Efficient for handling multiple threads with controlled execution.

        Example:

            ```
                import java.util.concurrent.ExecutorService;
                import java.util.concurrent.Executors;

                public class Main {
                    public static void main(String[] args) {
                        ExecutorService executor = Executors.newFixedThreadPool(2);

                        executor.execute(() -> System.out.println("Thread 1 is running..."));
                        executor.execute(() -> System.out.println("Thread 2 is running..."));

                        executor.shutdown();
                    }
                }
            ```

_______________________________________________________________________________________

*   What are the differences between Callable and Runnable ?

>>  (1) Functional Interface:

        - Both are functional interfaces, so they can be used with lambda expressions.

        - However, Callable is more suitable when you need to return a result or throw 
          an exception.

    (2) Return Type:

        - Runnable does not return a result. Its run() method returns void.

        - Callable returns a result. Its call() method returns a value of type V.

    (3) Exception Handling:
    
        - Runnable cannot throw checked exceptions from the run() method.

        - Callable can throw checked exceptions from the call() method.

    (4) Use with ExecutorService:

        - Runnable tasks submitted to an ExecutorService return a Future<?>, but the 
          result is always null unless you manually set a result.

        - Callable tasks return a Future<V>, where V is the result of the call() method.

    (5) Use Case:

        - Use Runnable when you just want to run a task in the background and don’t 
          need a result.

        - Use Callable when you want the task to produce a result or may throw an exception.

    (6) Example:

        - Runnable Example – No return, no checked exception

            Main.class:

                ```
                    import java.util.concurrent.ExecutorService;
                    import java.util.concurrent.Executors;

                    public class Main {
                        public static void main(String[] args) {
                            Runnable task = () -> {
                                System.out.println("Runnable is running...");
                            };
                            ExecutorService executor = Executors.newSingleThreadExecutor();
                            executor.submit(task); // returns Future<?> but result is always null
                            executor.shutdown();
                        }
                    }
                ```
        
        - Callable Example – Returns result, can throw exception

            Main.class:

                ```
                    import java.util.concurrent.*;

                    public class Main {
                        public static void main(String[] args) {
                            Callable<String> task = () -> {
                                Thread.sleep(2000); // simulate delay
                                return "Callable completed!";
                            };
                            ExecutorService executor = Executors.newSingleThreadExecutor();
                            Future<String> future = executor.submit(task);
                            try {
                                String result = future.get(); // blocks until result is available
                                System.out.println("Result: " + result);
                            } catch (InterruptedException | ExecutionException e) {
                                e.printStackTrace();
                            } finally {
                                executor.shutdown();
                            }
                        }
                    }
                ```

_______________________________________________________________________________________

*   Explain Thread Lifecycle in detail.

>>  A thread in Java goes through five states during its lifecycle:

        (1) New (Created)
        (2) Runnable
        (3) Blocked (Waiting for a resource)
        (4) Waiting
        (5) Timed Waiting 
        (6) Terminated (Dead)

    (1) New (Created) State:

        - A thread is in the new state when it is created but has not started execution yet.

        - It remains in this state until the start() method is called.

        Example:

            ```
                Thread t1 = new Thread(() -> System.out.println("Thread Running"));
            ```

    (2) Runnable State:

        - After calling start(), the thread moves to the runnable state.

        - The thread is ready to run, but CPU scheduling determines when it will execute.

        - The thread may or may not be running at a given moment.

        Example:

            ```
                Thread t1 = new Thread(() -> System.out.println("Thread Running"));
                t1.start();  // Moves to the Runnable state
            ```

    (3) Blocked State:

        - A thread moves to the blocked state when it tries to access a synchronized 
          resource that is currently held by another thread.

        - It remains blocked until the resource is released.

        Example:

            SharedResource.class:

                ```
                    class SharedResource {

                        synchronized void method() {
                            System.out.println(Thread.currentThread().getName() + " is executing...");
                            try { Thread.sleep(1000); } catch (InterruptedException e) {}
                        }
                    }
                ```
            
            Main.class:

                ```
                    public class Main {
                        public static void main(String[] args) {
                            SharedResource resource = new SharedResource();

                            Thread t1 = new Thread(() -> resource.method(), "Thread-1");
                            Thread t2 = new Thread(() -> resource.method(), "Thread-2");

                            t1.start();
                            t2.start();  // t2 will be blocked until t1 releases the lock
                        }
                    }
                ```

    (4) Waiting State:

        - A thread moves to the waiting when it is waiting for another thread's action.

        - A thread enters this state using wait(), join(), or park() and stays here until 
          another thread notifies it.

        Example:

            Task.class:

                ```
                    class Task {

                        synchronized void doWork() throws InterruptedException {
                            System.out.println("Waiting for notification...");
                            wait();  // Moves to Waiting state
                            System.out.println("Resumed after notification");
                        }

                        synchronized void notifyTask() {
                            notify();  // Wakes up waiting thread
                        }
                    }
                ```

                ```
                    public class Main {
                        public static void main(String[] args) throws InterruptedException {
                            Task task = new Task();

                            Thread t1 = new Thread(() -> {
                                try { 
                                    // task t1 moves to the waiting state
                                    task.doWork(); 
                                } 
                                catch (InterruptedException e) {}
                            });

                            Thread t2 = new Thread(() -> {
                                try { 
                                    // task t2 notifies t1 to wakes up waiting thread  
                                    task.notifyTask(); 
                                } 
                                catch (InterruptedException e) {}
                            });

                            // t1 waits indefinitely until another thread calls notify().
                            t1.start();

                            Thread.sleep(2000); // Simulate some delay

                            t2.start();
                        }
                    }
                ```

    (5) Timed Waiting State:

        - A thread moves to timed waiting if it calls sleep(), wait(timeout), or 
          join(timeout).

        - It will automatically wake up after the time expires.

        Example:

            ```
                public class Main {
                    public static void main(String[] args) throws InterruptedException {
                        Thread t1 = new Thread(() -> {
                            try {
                                System.out.println("Thread Sleeping...");
                                Thread.sleep(3000);  // Moves to Timed Waiting
                                System.out.println("Thread Awake...");
                            } catch (InterruptedException e) {}
                        });

                        t1.start();
                    }
                }
            ```

    (6) Terminated (Dead) State:

        - A thread moves to the terminated state when it completes execution or it is 
          manually stopped using stop() (deprecated).

        - A terminated thread cannot be restarted.

        Example:

                ```
                    public class Main {
                        public static void main(String[] args) {
                            Thread t1 = new Thread(() -> System.out.println("Thread Executed"));
                            t1.start();

                            try { 
                                // main thread will wait until t1 completes  
                                t1.join(); 
                            } catch (InterruptedException e) {}

                            // Once t1 execution completes, the thread is terminated.
                            System.out.println("Thread is Terminated");
                        }
                    }
                ```

_______________________________________________________________________________________

*   Which methods affect Thread states ?

>>  (1) start(): 

        - Moves from NEW → RUNNABLE
    
    (2) sleep(ms), wait(ms), join(ms): 	
    
        - Moves from RUNNING → TIMED WAITING

    (3) wait(), join():	
    
        - Moves from RUNNING → WAITING
    
    (4) notify():	
    
        - Moves from WAITING → RUNNABLE

    (5) synchronized:	
    
        - Moves to BLOCKED if another thread holds the lock

    (6) stop()(Deprecated): 
        
        - Moves directly to TERMINATED

_______________________________________________________________________________________

*   Explain Thread Priority in detail.

>>  Thread priority determines the relative importance of a thread in scheduling.

    Threads with higher priority get more CPU time than lower-priority threads, but it 
    does not guarantee execution order.

    The Java thread scheduler uses preemptive scheduling and time slicing based on priority.

    Default Thread Priorities:

        - Every thread in Java has a priority ranging from 1 to 10.

        - The Thread class defines three priority constants:

            (1) Thread.MIN_PRIORITY - 1: Lowest priority
            
            (2) Thread.NORM_PRIORITY - 5: Default priority (assigned to threads by default)
            
            (3) Thread.MAX_PRIORITY	- 10: Highest priority

        Example:

            ```
                public class Main {
                    public static void main(String[] args) {

                        Thread t = new Thread(() -> System.out.println("Thread running..."));
                        System.out.println("Default Priority: " + t.getPriority()); // Output: 5 (NORM_PRIORITY)
                    }
                }
            ```

_______________________________________________________________________________________

*   Does higher Priority guarantee execution order ?

>>  No, thread priority does not guarantee execution order.

    The thread scheduler decides which thread gets CPU time based on priority and other 
    factors like OS scheduling policies.

    Even if a thread has a higher priority, it may not always execute first.

    Example: 

        MyThread.class:

            ```
                class MyThread extends Thread {

                    public void run() {
                        for (int i = 0; i < 5; i++) {
                            System.out.println(Thread.currentThread().getName() + " is running...");
                        }
                    }
                }
            ```

        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) {
                        MyThread t1 = new MyThread();
                        MyThread t2 = new MyThread();
                        
                        t1.setPriority(Thread.MIN_PRIORITY); // Priority = 1
                        t2.setPriority(Thread.MAX_PRIORITY); // Priority = 10
                        
                        t1.start();
                        t2.start();
                    }
                }
            ```

        Output (May Vary):

            - Even though Thread-1 has higher priority, Thread-0 still runs due to 
              thread scheduling behavior.

            ```
                Thread-0 is running...
                Thread-1 is running...
                Thread-1 is running...
                Thread-1 is running...
                Thread-0 is running...
            ```

_______________________________________________________________________________________

*   How Thread scheduler uses Priority ?

>>  The thread scheduler is part of the OS and JVM.

    It uses two mechanisms to manage CPU time among threads:

    (1) Preemptive Scheduling:

        - The highest-priority thread gets CPU time whenever it is ready.

        - If a higher-priority thread becomes available, it preempts (interrupts) 
          lower-priority threads.

    (2) Time-Slicing (Round-Robin):

        - If multiple threads have the same priority, CPU time is divided equally 
          among them in a round-robin fashion.

        Example: 

            MyThread.class:

                ```
                    class MyThread extends Thread {

                        public void run() {
                            for (int i = 0; i < 3; i++) {
                                System.out.println(Thread.currentThread().getName() + " executing...");
                            }
                        }
                    }
                ```
            
            Main.class:

                ```
                    public class Main {
                        public static void main(String[] args) {
                            MyThread t1 = new MyThread();
                            MyThread t2 = new MyThread();
                            MyThread t3 = new MyThread();
                            
                            // All threads have the same priority
                            t1.setPriority(Thread.NORM_PRIORITY);  
                            t2.setPriority(Thread.NORM_PRIORITY);  
                            t3.setPriority(Thread.NORM_PRIORITY);  
                            
                            t1.start();
                            t2.start();
                            t3.start();
                        }
                    }
                ```

            Output (May Vary):

                - All threads have equal CPU time as they have the same priority.

                ```
                    Thread-0 executing...
                    Thread-1 executing...
                    Thread-2 executing...
                    Thread-0 executing...
                    Thread-1 executing...
                    Thread-2 executing...
                ```

_______________________________________________________________________________________

*   What are the best practices for using Thread Priority ?

>>  Use priorities wisely. Don't rely on them to control execution order.

    Do not assume high-priority threads will always execute first. Scheduling depends on
    OS and JVM.

    Prefer using Thread.NORM_PRIORITY (default priority) unless necessary.
    
    For critical tasks, use proper thread synchronization instead of priority.

_______________________________________________________________________________________

*   Explain join() method in detail.

>>  The join() method is used to pause the execution of the current thread until the 
    specified thread has completed its execution.

    How it Works:
        
        - The calling thread pauses until the target thread completes.

        - If a timeout is specified, the calling thread will resume after the given 
          time even if the target thread hasn’t finished.

        - If the target thread is already finished, join() returns immediately.

        - It must be called on a started thread (t.start()), otherwise, it has no effect.

    Example: Using join()

        MyThread.class:

            ```
                class MyThread extends Thread {
                    
                    public void run() {
                        for (int i = 1; i <= 3; i++) {
                            System.out.println(Thread.currentThread().getName() + " - Count: " + i);
                            try {
                                Thread.sleep(1000);  // Simulate some work
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
            ```

        - Since t1.join() is called on Main thread, Main thread is a calling Thread and 
          t1 is a target thread.

        Main.class:

            ```
                public class Main {

                    public static void main(String[] args) {
                        MyThread t1 = new MyThread();
                        MyThread t2 = new MyThread();

                        t1.start();
                        try {
                            t1.join();  // Main thread waits for t1 to finish
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                        // t2 starts only after t1 is finished since Main thread is waiting
                        t2.start();  
                    }
                }
            ```
        
        Output:

            ```
                Thread-0 - Count: 1
                Thread-0 - Count: 2
                Thread-0 - Count: 3
                Thread-1 - Count: 1
                Thread-1 - Count: 2
                Thread-1 - Count: 3
            ```

    Example: Using join(long millis)

        - Since join(2000) allows waiting only for 2 seconds, the main thread resumes 
          execution before t1 is finished.

        Main.class:
    
            ```
                public class Main {
                    public static void main(String[] args) {
                        MyThread t1 = new MyThread();
                        t1.start();

                        try {
                            t1.join(2000);  // Main thread waits at most 2 seconds for t1
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                        System.out.println("Main thread resumes execution.");
                    }
                }
            ```

        Output:

            ```
                Thread-0 - Count: 1
                Thread-0 - Count: 2
                Main thread resumes execution.
                Thread-0 - Count: 3
                Thread-0 - Count: 4
                Thread-0 - Count: 5
            ```

_______________________________________________________________________________________

*   Explain wait() method in detail.

>>  The wait() method is used for inter-thread communication. 
    
    It causes the current thread to release the lock and enter a waiting state until 
    another thread notifies it using notify() or notifyAll().

    How it Works:

        - Must be called within a synchronized block or method, otherwise it throws 
          IllegalMonitorStateException.

        - The thread calling wait() releases the lock (monitor) of the object 
          and enters a waiting state.

        - Another thread must call notify() or notifyAll() to wake up the waiting thread.

        - Once notified, the waiting thread reacquires the lock before resuming execution.

    Example: Using wait()

        Task.class:

            ```
                class Task {
                    public synchronized void doTask() {
                        System.out.println("Task started...");
                        try {
                            wait();  // The thread waits here until it's notified
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println("Task resumed after notification!");
                    }

                    public synchronized void completeTask() {
                        System.out.println("Task completed. Notifying...");
                        notify();  // Notify the waiting thread to continue
                    }
                }
            ```
        
        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) {
                        Task task = new Task();

                        Thread t1 = new Thread(task::doTask);
                        Thread t2 = new Thread(task::completeTask);

                        t1.start();
                        
                        try {
                            Thread.sleep(3000);  // Simulate some delay before notifying
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        
                        t2.start();
                    }
                }
            ```

        Output:

            ```
                Task started...
                (Task is waiting...)
                Task completed. Notifying...
                Task resumed after notification!

            ```

    Example: Using wait(long millis)

        TimerTask.class:

            ```
                class TimerTask {
                    public synchronized void startTask() {
                        System.out.println("Task started...");
                        try {
                            wait(3000);  // Wait for 3 seconds
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println("Task completed after waiting.");
                    }
                }
            ```
        
        Main.class:
        
            ```
                public class Main {
                    public static void main(String[] args) {
                        TimerTask task = new TimerTask();
                        Thread t1 = new Thread(task::startTask);
                        t1.start();
                    }
                }
            ```
        Output

            ```
                Task started...
                (Task waits for 3 seconds)
                Task completed after waiting.
            ```

_______________________________________________________________________________________

*   Explain sleep() method in detail.

>>  The sleep() method is used to pause the execution of the current thread for a 
    specified period. 
    
    It belongs to the Thread class and allows a thread to go into a timed waiting state.

    How it Works:

        - The thread executing sleep() pauses execution for the given duration.

        - It does not release any locks if the thread is in a synchronized block.

        - The thread resumes execution after the sleep time expires or if interrupted.

    Example: Using sleep()

        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) {
                        System.out.println("Task started...");
                        
                        try {
                            Thread.sleep(3000);  // Pauses execution for 3 seconds
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        
                        System.out.println("Task completed after sleep.");
                    }
                }
            ```
        
        Output:

            ```
                Task started...
                (Task pauses for 3 seconds)
                Task completed after sleep.
            ```

    Example: Handling InterruptedException

        - If another thread calls interrupt() on a sleeping thread, it throws InterruptedException.

        Task.class:

            ```
                class Task implements Runnable {
                    public void run() {
                        try {
                            System.out.println("Thread sleeping...");
                            Thread.sleep(5000);
                            System.out.println("Thread woke up!");
                        } catch (InterruptedException e) {
                            System.out.println("Thread was interrupted!");
                        }
                    }
                }
            ```
        
        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) {
                        Thread t = new Thread(new Task());
                        t.start();

                        try {
                            Thread.sleep(2000);  // Main thread waits 2 seconds before interrupting
                            t.interrupt();       // Interrupt the sleeping thread
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            ```
            
        Output:

            ```
                Thread sleeping...
                Thread was interrupted!
            ```

_______________________________________________________________________________________

*   Explain yield() method in detail.

>>  yield() is a static method in the Thread class. 

    It's a hint to the thread scheduler that the current thread is willing to pause and 
    give a chance for other threads of the same priority to execute.

    It’s important to note that yield() is just a request to the scheduler and not a guarantee.

    What Actually Happens When We Call yield()?
        
        - The current running thread moves from Running state to Runnable state.

        - The thread scheduler is free to pick any thread from the Runnable pool (could 
          be the same thread again).

        - No blocking or waiting as it's a very lightweight pause.

    When is yield() Used?

        - When you want to avoid starvation (letting other equal-priority threads run).

        - For fine-tuning multi-threaded programs (but rarely used in practice).        

    Example:

        MyThread.class:

            ```
                class MyThread extends Thread {
                    public void run() {
                        for (int i = 1; i <= 5; i++) {
                            System.out.println(Thread.currentThread().getName() + " : " + i);
                            Thread.yield(); // Hint to scheduler
                        }
                    }
                }
            ```

        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) {
                        MyThread t1 = new MyThread();
                        MyThread t2 = new MyThread();

                        t1.start();
                        t2.start();
                    }
                }
            ```

        Possible Output:

            ```
                Thread-0 : 1
                Thread-1 : 1
                Thread-0 : 2
                Thread-1 : 2
                Thread-0 : 3
                Thread-1 : 3
                Thread-0 : 4
                Thread-1 : 4
                Thread-0 : 5
                Thread-1 : 5
            ```

_______________________________________________________________________________________

*   What are the differences between join(), wait() and sleep() method ?

>>  (1) Purpose:

        - join() makes the current thread wait until another thread (on which join() is called) 
          finishes execution.

        - wait() makes the current thread wait until another thread calls notify() or notifyAll() 
          on the same object.

        - sleep() pauses the execution of the current thread for a specified duration but does 
          not release any lock if held.

    (2) Lock Handling:

        - join() does not release any lock while waiting for the other thread to finish.

        - wait() releases the lock so that other threads can acquire it.

        - sleep() does not release any lock if it is inside a synchronized block.

    (3) Where it is used:

        - join() used when one thread depends on the completion of another thread.

        - wait() used in inter-thread communication (Producer-Consumer problems, etc.).

        - sleep() used when a thread needs to pause execution for a certain period.

    (4) How it resumes:

        - join() resumes when the target thread completes execution.

        - wait() resumes when another thread calls notify() or notifyAll() on the same object.

        - sleep() resumes after the specified sleep time expires or if interrupted.

_______________________________________________________________________________________

*   Explain notify() method in detail.

>>  The notify() method is used in inter-thread communication to wake up a single thread 
    that is waiting on an object's lock. 
    
    It must be called inside a synchronized block or method, otherwise, it throws 
    IllegalMonitorStateException.

    It does not release the lock immediately. The notified thread must wait until the 
    notifying thread exits the synchronized block.

    If no thread is waiting, notify() has no effect.

    How it Works:

        - A thread that calls wait() on an object releases the lock and enters the waiting state.

        - Another thread, after completing some task, calls notify() on the same object.

        - notify() wakes up only one of the waiting threads (randomly selected if multiple 
          threads are waiting).

        - The awakened thread still needs to re-acquire the object's lock before proceeding.

    Example:

        Task.class:

            ```
                class Task {
                    public synchronized void doTask() {
                        System.out.println("Task started...");
                        try {
                            wait();  // The thread waits here until it's notified
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println("Task resumed after notification!");
                    }

                    public synchronized void completeTask() {
                        System.out.println("Task completed. Notifying...");
                        notify();  // Notify the waiting thread to continue
                    }
                }
            ```
        
        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) {
                        Task task = new Task();

                        Thread t1 = new Thread(task::doTask);
                        Thread t2 = new Thread(task::completeTask);

                        t1.start();
                        
                        try {
                            Thread.sleep(3000);  // Simulate some delay before notifying
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        
                        t2.start();
                    }
                }
            ```

        Output:

            ```
                Task started...
                (Task is waiting...)
                Task completed. Notifying...
                Task resumed after notification!

            ```

_______________________________________________________________________________________

*   Explain notifyAll() method in detail.

>>  The notifyAll() method is similar to notify(), but instead of waking up just one 
    thread, it notifies all waiting threads.

    It is best suited when multiple threads are waiting, notifyAll() prevents indefinite 
    waiting (deadlocks).

    How it Works:

        - A thread that calls wait() on an object releases the lock and enters the 
          waiting state.

        - Another thread calls notifyAll() on the same object.

        - All waiting threads are awakened, but they must compete for the lock before 
          proceeding.

        - The first thread to acquire the lock continues execution, while others remain 
          in the runnable state.

_______________________________________________________________________________________

*   Explain interrupt() method in detail.

>>  The interrupt() method is used to interrupt a thread that is either sleeping, 
    waiting, or running. 
    
    It does not forcefully stop the thread but only sets the interrupt status flag of the 
    thread, signaling that it should stop execution or handle the interruption appropriately.

    - It is use to stop a thread gracefully instead of forcefully terminating it.

    How it Works:

        - If the thread is in sleep (sleep()), wait (wait()), or join (join()), 
          it throws an InterruptedException.

        - If the thread is running normally, it does not stop immediately; it only sets 
          an interrupt flag (Thread.interrupted() == true).

        - If a thread is already finished, interrupt() has no effect.

    Example: Interrupting a Sleeping Thread

        MyThread.class:

            ```
                class MyThread extends Thread {
                    public void run() {
                        try {
                            System.out.println("Thread is going to sleep...");
                            Thread.sleep(5000);  // Sleep for 5 seconds
                            System.out.println("Thread woke up normally.");
                        } catch (InterruptedException e) {
                            System.out.println("Thread was interrupted while sleeping!");
                        }
                    }
                }
            ```

        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) {
                        MyThread t1 = new MyThread();
                        t1.start();

                        try {
                            Thread.sleep(2000);  // Main thread sleeps for 2 seconds
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                        t1.interrupt();  // Interrupting t1 while it is sleeping
                    }
                }
            ```
        
        Output:

            ```
                Thread is going to sleep...
                (Thread sleeping for 2 seconds)
                Thread was interrupted while sleeping!
            ```

    Example: Interrupting a Running Thread

        MyThread.class:

            ```
                class MyThread extends Thread {
                    public void run() {
                        for (int i = 1; i <= 5; i++) {
                            System.out.println("Thread is running: " + i);
                            if (Thread.interrupted()) {
                                System.out.println("Thread is interrupted, stopping execution.");
                                return;
                            }
                        }
                    }
                }
            ```

        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) {
                        MyThread t1 = new MyThread();
                        t1.start();

                        try {
                            Thread.sleep(10);  // Give the thread some time to run
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                        t1.interrupt();  // Interrupt the thread
                    }
                }
            ```
        
        Output:

            ```
                Thread is running: 1
                Thread is running: 2
                Thread is interrupted, stopping execution.
            ```

_______________________________________________________________________________________

*   Explain the Race conditions & Data inconsistency in detail.

>>  A race condition occurs when two or more threads try to read, write, or update a 
    shared resource concurrently, leading to unpredictable behavior.

    This happens when operation is not atomic (executes completely or not at all).

    Example:

        Counter.class:

            ```
                class Counter {
                    private int count = 0;

                    public void increment() {
                        count++;  // Not thread-safe
                    }

                    public int getCount() {
                        return count;
                    }
                }
            ```

        Main.class:

            - Since count++ is not an atomic operation, some increments are lost.

            - The final result should be 2000, but due to the race condition, it is unpredictable.

            ```
                public class Main {
                    public static void main(String[] args) {
                        Counter counter = new Counter();

                        // Thread 1 increments the counter 1000 times
                        Thread t1 = new Thread(() -> {
                            for (int i = 0; i < 1000; i++) {
                                counter.increment();
                            }
                        });

                        // Thread 2 increments the counter 1000 times
                        Thread t2 = new Thread(() -> {
                            for (int i = 0; i < 1000; i++) {
                                counter.increment();
                            }
                        });

                        t1.start();
                        t2.start();

                        try {
                            t1.join();
                            t2.join();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                        // Expected: 2000, but output may vary due to race conditions
                        System.out.println("Final Counter Value: " + counter.getCount());
                    }
                }
            ```

        Output:

            ```
                Final Counter Value: 1897  // (May vary)
            ```

_______________________________________________________________________________________

*   How to Prevent Race Conditions & Data Inconsistency ?

>>  (1) Using Synchronized Methods:

        - Ensures only one thread at a time can access the method.

        Example:

            ```
                class Counter {
                    private int count = 0;

                    public synchronized void increment() {
                        count++;  // Now thread-safe
                    }

                    public int getCount() {
                        return count;
                    }
                }
            ```

    (2) Using Synchronized Blocks:

        - Allows fine-grained locking for specific parts of the code.

        Example:

            ```
                class Counter {
                    private int count = 0;

                    public void increment() {
                        synchronized (this) {
                            count++;
                        }
                    }
                }
            ```

    (3) Using Atomic Variables (Preferred for Performance):

        - Uses AtomicInteger, which provides thread-safe atomic operations.

        Example:

            ```
                import java.util.concurrent.atomic.AtomicInteger;

                class Counter {
                    private AtomicInteger count = new AtomicInteger(0);

                    public void increment() {
                        count.incrementAndGet();  // Atomic operation
                    }

                    public int getCount() {
                        return count.get();
                    }
                }
            ```
    
    (4) Using Locks (ReentrantLock):

        - More flexible than synchronized, allows better control.

        Example:

            ```
                import java.util.concurrent.locks.Lock;
                import java.util.concurrent.locks.ReentrantLock;

                class Counter {
                    private int count = 0;
                    private Lock lock = new ReentrantLock();

                    public void increment() {
                        lock.lock();
                        try {
                            count++;
                        } finally {
                            lock.unlock();
                        }
                    }
                }
            ```

    (5) Using volatile (Only for Visibility, Not Atomicity):

        - Ensures latest value is always visible across threads but does not solve 
          race conditions.

        Example:

            ```
                class SharedResource {
                    private volatile boolean flag = false;

                    public void setFlag() {
                        flag = true;  // Latest value is visible across threads
                    }
                }
            ```

_______________________________________________________________________________________

*   Explain synchronized keyword in detail and and how it prevents race condition and 
    data inconsistency ?

>>  The synchronized keyword is used to prevent race conditions and ensure thread safety 
    by allowing only one thread at a time to execute a critical section of code.

    It prevents multiple threads from reading and modifying the same variable simultaneously,
    thereby resolving race condition and data inconsistency.

    Types of Synchronization:

        (1) Method Synchronization:
            
            - The synchronized keyword locks the entire method on the calling object, so only one 
            thread can execute it at a time.

            - If Thread A is executing increment(), Thread B must wait until Thread A finishes.

            Example: 

                ```
                    class Counter {
                        private int count = 0;

                        public synchronized void increment() {  // Synchronized method
                            count++;  
                        }

                        public int getCount() {
                            return count;
                        }
                    }
                ```

        (2) Block Synchronization:

            - Instead of locking the entire method, we lock only a critical section of the code.

            - It is more efficient than method synchronization because it locks only the critical 
              part of the code, allowing other non-synchronized methods to execute freely.

            Example: 

                - Thread-1 enters the synchronized (this) block → it locks the object (this).

                - Thread-2 also wants to enter doSynchronizedWork() → must wait, because it's 
                  trying to acquire the same lock (this).

                - Thread-3 is calling an unsynchronized method, so it executes immediately — not 
                  blocked, because it doesn’t try to acquire the lock.

                MyTask.class:

                    ```
                        public class MyTask {

                            public void unsynchronizedMethod() {
                                System.out.println(Thread.currentThread().getName() + " is in unsynchronized method.");
                            }

                            public void doSynchronizedWork() {
                                synchronized (this) {
                                    System.out.println(Thread.currentThread().getName() + " entered synchronized block.");
                                    try { Thread.sleep(2000); } catch (InterruptedException e) {}
                                    System.out.println(Thread.currentThread().getName() + " exiting synchronized block.");
                                }
                            }
                        }
                    ```
                
                Main.class:

                    ```
                        public class Main {
                            public static void main(String[] args) {
                                MyTask task = new MyTask();

                                Thread t1 = new Thread(() -> task.doSynchronizedWork(), "Thread-1");
                                Thread t2 = new Thread(() -> task.doSynchronizedWork(), "Thread-2");
                                Thread t3 = new Thread(() -> task.unsynchronizedMethod(), "Thread-3");

                                t1.start();
                                t2.start();
                                t3.start();
                            }
                        }
                    ```

        (3) Static Synchronization:

            - Used when multiple threads access a shared static resource.

            - synchronized on a static method locks the entire class (SharedResource.class), not 
              just an object instance.

            Example: 

                ```
                    class SharedResource {
                        private static int count = 0;

                        public static synchronized void increment() {  // Static synchronized method
                            count++;
                        }

                        public static int getCount() {
                            return count;
                        }
                    }
                ```

    Limitations:

        (1) Performance Overhead:

            - Synchronization reduces performance due to locking and context switching.

            - It is slower than atomic operations (AtomicInteger).

        (2) Deadlocks:

            - If two threads wait for each other to release a lock, a deadlock occurs.

        (3) Fairness Issue:

            - No guarantee of fairness—some threads may wait indefinitely while others 
              keep acquiring locks.

_______________________________________________________________________________________

*   Explain Atomic Variables in detail.

>>  Java provides atomic variables to perform thread-safe operations without using locks. 

    Atomic variables provide a lock-free alternative using CPU-level atomic operations 
    (like CAS – Compare And Swap).

    It is recommended when only a single variable or field needs atomic updates, not complex ones.
    
    How it Works:
        
        - Atomic variables avoid race conditions using Compare And Swap (CAS):

            - Read the current value
            - Compute the new value
            - Use CAS instruction to update the variable only if the value is still the same
            - If another thread modifies the value before the CAS operation succeeds, it retries 
              until successful.

    How CAS Works:

        - Here if another thread changes count before compareAndSet() succeeds, the loop retries until 
          successful.

        ```
            while (true) {
                int existingValue = count.get();  // Step 1: Read current value
                int newValue = existingValue + 1; // Step 2: Compute new value
                if (count.compareAndSet(existingValue, newValue)) { // Step 3: CAS operation
                    break;
                }
            }
        ```

    Types of Atomic Variables:

        - Java provides atomic classes for different primitive types and objects:

            (1) AtomicInteger: Atomic operations for int values
            
            (2) AtomicLong: Atomic operations for long values
            
            (3) AtomicBoolean: Atomic operations for boolean values
            
            (4) AtomicReference<T>:	Atomic operations for objects of type T
            
            (5) AtomicIntegerArray: Atomic operations for an int[] array
            
            (6) AtomicLongArray: Atomic operations for a long[] array
            
            (7) AtomicReferenceArray<T>: Atomic operations for an array of objects

    Example: AtomicInteger

        Counter.class:

            ```
                import java.util.concurrent.atomic.AtomicInteger;

                class Counter {
                    private AtomicInteger count = new AtomicInteger(0);

                    public void increment() {
                        count.incrementAndGet();  // Atomic increment
                    }

                    public int getCount() {
                        return count.get();
                    }
                }
            ```

        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) throws InterruptedException {
                        Counter counter = new Counter();

                        Thread t1 = new Thread(() -> {
                            for (int i = 0; i < 1000; i++) counter.increment();
                        });

                        Thread t2 = new Thread(() -> {
                            for (int i = 0; i < 1000; i++) counter.increment();
                        });

                        t1.start();
                        t2.start();

                        t1.join();
                        t2.join();

                        System.out.println("Final Count: " + counter.getCount());  // Always 2000
                    }
                }
            ```

    Example: AtomicReference

        User.class:

            ```
                class User {
                    String name;
                    User(String name) { this.name = name; }
                }
            ```

        Main.class:

            ```
                import java.util.concurrent.atomic.AtomicReference;

                public class Main {
                    public static void main(String[] args) {
                        AtomicReference<User> userRef = new AtomicReference<>(new User("Alice"));

                        // Atomically update reference
                        userRef.compareAndSet(userRef.get(), new User("Bob"));

                        System.out.println("Updated user: " + userRef.get().name); // Bob
                    }
                }
            ```

_______________________________________________________________________________________

*   Explain Deadlocks in detail. 

>>  A deadlock occurs when two or more threads are blocked forever because each thread 
    is waiting for a resource held by another thread. 
    
    This results in an infinite wait, causing the program to hang.

    Example:

        (1) Thread-1:
            
            - Enters methodA().
            - Locks resourceA (this).
            - Goes to sleep for 1 second.

        (2) During that sleep, Thread-2:
            
            - Enters methodB().
            - Locks resourceB (this).
            - Goes to sleep for 1 second.

        (3) When both threads wake up:
            
            - Thread-1 tries to lock resourceB (but it's already locked by Thread-2).
            - Thread-2 tries to lock resourceA (but it's already locked by Thread-1).
            - Both threads are now waiting for each other’s locks leading to Deadlock.

        Resource.class:

            ```
                class Resource {

                    void methodA() {
                        // resourceA is calling this method so resourceA (this) will be locked
                        synchronized (this) {
                 
                            System.out.println(Thread.currentThread().getName() + " locked Resource-A");
                            try { Thread.sleep(1000); } catch (InterruptedException e) {}
                            
                            // Thread will lock the object resourceB while executing below code
                            synchronized (Main.resourceB) { 
                                System.out.println(Thread.currentThread().getName() + " locked Resource-B");
                            }
                        }
                    }

                    void methodB() {
                        // resourceB is calling this method so resourceB (this) will be locked
                        synchronized (this) {

                            System.out.println(Thread.currentThread().getName() + " locked Resource-B");
                            try { Thread.sleep(1000); } catch (InterruptedException e) {}

                            // Thread will lock the object resourceA while executing below code
                            synchronized (Main.resourceA) { 
                                System.out.println(Thread.currentThread().getName() + " locked Resource-A");
                            }
                        }
                    }
                }
            ```
        
        Main.class:

            ```
                public class Main {
                    static Resource resourceA = new Resource();
                    static Resource resourceB = new Resource();

                    public static void main(String[] args) {
                        Thread t1 = new Thread(() -> resourceA.methodA(), "Thread-1");
                        Thread t2 = new Thread(() -> resourceB.methodB(), "Thread-2");

                        t1.start();
                        t2.start();
                    }
                }
            ```

_______________________________________________________________________________________

*   How to prevent Deadlocks ?

>>  (1) Enforce Lock Ordering:

        - Deadlocks occurs due to circular wait — one thread holds Lock A and waits 
          for Lock B, while another holds Lock B and waits for Lock A.

        - By always acquiring locks in a fixed order (e.g., always lock resourceA before resourceB), 
          threads never end up in circular wait.

        - Even if multiple threads try to access shared resources, they will all request the locks 
          in the same order, avoiding conflict.

        ```
            class SafeResource {
                void safeMethod() {
                    // resourceA lock will always be acquired first before acquiring resourceB.
                    synchronized (Main.resourceA) {
                        System.out.println(Thread.currentThread().getName() + " locked Resource-A");

                        synchronized (Main.resourceB) {
                            System.out.println(Thread.currentThread().getName() + " locked Resource-B");
                        }
                    }
                }
            }

    (2) Use tryLock() instead of synchronized:

        - ReentrantLock.tryLock() is non-blocking — if the lock is not available, it immediately 
          returns false, and the thread can take an alternate path (retry, log, skip, etc.).

        - If lockB isn’t available, thread backs out without getting stuck.

        SafeResource.class:

            ```
                class SafeResource {

                    private static ReentrantLock lockA = new ReentrantLock();
                    private static ReentrantLock lockB = new ReentrantLock();

                    void safeMethod() {
                        if (lockA.tryLock()) {
                            try {
                                System.out.println(Thread.currentThread().getName() + " locked Resource-A");
                                
                                if (lockB.tryLock()) {
                                    try {
                                        System.out.println(Thread.currentThread().getName() + " locked Resource-B");
                                    } finally {
                                        lockB.unlock();
                                    }
                                }
                            } finally {
                                lockA.unlock();
                            }
                        }
                    }
                }
            ```

    (3) Use a timeout on locks:

        - Another way to avoid deadlocks is by setting a timeout for acquiring locks.

        - If the lock cannot be acquired within the timeout, the thread exits instead 
          of waiting forever.

            ```
                class SafeResource {
                    private static ReentrantLock lockA = new ReentrantLock();
                    private static ReentrantLock lockB = new ReentrantLock();

                    void safeMethod() {
                        if (lockA.tryLock(1, TimeUnit.SECONDS)) {
                            try {
                                // if lockB can't be acquired for 1 sec, then it will exit 
                                if (lockB.tryLock(1, TimeUnit.SECONDS)) {
                                    try {
                                        System.out.println("Locked both resources safely");
                                    } finally {
                                        lockB.unlock();
                                    }
                                }
                            } finally {
                                lockA.unlock();
                            }
                        } else {
                            System.out.println("Could not acquire locks, avoiding deadlock");
                        }
                    }
                }
            ```

    (4) Use a single lock for related resources
        
        - By wrapping access to all related shared resources under a single lock, you 
          eliminate the need for multiple locks entirely.
        
        - Since only one lock is used, no deadlock can occur.
    
        Example:

            SingleLockResource.class:

                ```
                    class SingleLockResource {
                        private final Object lock = new Object();

                        void safeMethod() {
                            synchronized (lock) {
                                System.out.println(Thread.currentThread().getName() + " locked safely");
                            }
                        }
                    }
                ```

_______________________________________________________________________________________

*   Explain Lock in detail.

>>  In Java, a Lock is an interface provided in the java.util.concurrent.locks package 
    that offers more control over thread synchronization compared to synchronized blocks.

    Instead of implicitly locking a block or method (synchronized), you explicitly 
    acquire and release the lock.

    Explain:

        ```
            class Shared {
                private final ReentrantLock lock = new ReentrantLock();

                public void safeMethod() {
                    // explicitly acquiring a lock
                    lock.lock();  
                    try {
                        System.out.println(Thread.currentThread().getName() + " is executing safely.");
                    } finally {
                        lock.unlock();  // always release lock in finally block
                    }
                }
            }
        ```

_______________________________________________________________________________________

*   Explain various types of Locks in Java.

>>  (1) ReentrantLock (most commonly used):

        ReentrantLock is a class in the java.util.concurrent.locks package that implements 
        the Lock interface.

        A reentrant lock means thread can acquire the same lock multiple times without 
        getting blocked.

        Always release the lock. If you forget to unlock, it may lead to deadlocks or 
        threads starving forever.

        Key Features:

            (a) Explicit Locking:
            
                - Unlike synchronized, you must manually acquire and release the lock 
                  using lock() and unlock().

            (b) Reentrant Behavior: 
            
                - Same thread can lock multiple times without blocking itself.

            (c) Try to Acquire:
             
                - tryLock() lets you attempt to acquire the lock without waiting.

            (d) Timeout Support:
            
                - tryLock(timeout, unit) waits for the lock only up to a specified time.

        Example:

            SharedResource.class:

                ```
                    class SharedResource {
                        private final ReentrantLock lock = new ReentrantLock();

                        public void access() {
                            lock.lock(); // acquire the lock
                            try {
                                System.out.println(Thread.currentThread().getName() + " is working...");
                                Thread.sleep(1000);
                            } catch (InterruptedException e) {
                                Thread.currentThread().interrupt();
                            } finally {
                                lock.unlock(); // always release the lock
                            }
                        }
                    }
                ```

        Example (Reentrancy):

            SharedResource.class:

                ```
                    class SharedResource {
                        ReentrantLock lock = new ReentrantLock();

                        public void outer() {
                            lock.lock();
                            try {
                                System.out.println("Outer method");
                                inner(); // same thread can call inner()
                            } finally {
                                lock.unlock();
                            }
                        }

                        public void inner() {
                            lock.lock(); // same thread can lock again
                            try {
                                System.out.println("Inner method");
                            } finally {
                                lock.unlock(); // must unlock for each lock()
                            }
                        }
                    }
                ```

    (2) ReentrantReadWriteLock:
    
        ReentrantReadWriteLock provides a more flexible locking mechanism compared to 
        synchronized or ReentrantLock by allowing multiple threads to read a resource 
        simultaneously (if no thread is writing).

        It allows only one thread to write (exclusive access), while blocking all readers 
        and writers.

        Using synchronized or ReentrantLock for both read & write blocks all threads,
        even readers, which is inefficient when reads are more frequent than writes.

        It supports fair locking as longest waiting thread gets the lock first.
        
        It allows Lock Downgrade i.e. acquiring read lock after write lock but not Lock Upgrade i.e
        acquiring write lock after read lock.

        How it Works:

            - It has two locks internally
            
                (a) Read Lock (lock.readLock()):
                    
                    - Multiple threads can acquire read lock simultaneously as long as there
                      is no active writer.

                (b) Write Lock (lock.writeLock()):
                    
                    - Only one thread can acquire write lock and while writing, no other reader 
                      and writer is allowed.

        Example:

            ```
                class SharedResource {
                    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
                    private int data = 0;

                    // Reading data
                    void readData() {
                        lock.readLock().lock();
                        try {
                            System.out.println(Thread.currentThread().getName() + " reading: " + data);
                            Thread.sleep(1000);  // Simulate read delay
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        } finally {
                            lock.readLock().unlock();
                        }
                    }

                    // Writing data
                    void writeData(int value) {
                        lock.writeLock().lock();
                        try {
                            System.out.println(Thread.currentThread().getName() + " writing: " + value);
                            Thread.sleep(1000);  // Simulate write delay
                            data = value;
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        } finally {
                            lock.writeLock().unlock();
                        }
                    }
                }
            ```

_______________________________________________________________________________________

*   What are the differences between synchronized and lock ?

>>  (1) Flexibility and Control:

        - synchronized automatically acquires and releases the lock when the block/method
          is entered and exited.

        - Lock provides explicit locking and unlocking where developer can conditionally
          acquiring and releasing locks. If not released, it may lead to deadlock.


    (2) Try Locking Without Waiting:

        - synchronized does not provide any mechanism to try acquiring a lock without waiting.

        - Lock provides tryLock() method which allows a thread to attempt locking and 
          if unsuccessful, thread can proceed without waiting indefinitely.

    (3) Timeout Feature:

        - synchronized does not support timeout for acquiring a lock.

        - Lock provides tryLock(time, TimeUnit) where a thread waits for the specified 
          time and fails if the lock is not acquired.

    (4) Interruptible Locking:

        - Threads waiting to acquire synchronized lock cannot be interrupted. They must wait.

        - With Lock, lockInterruptibly() method allows a thread to respond to 
          interruptions while waiting for the lock.

    (5) Fairness Policy:

        - Synchronized does not support fairness. Thread scheduling is done by JVM.

        - Lock supports fairness by constructor. For e.g., new ReentrantLock(true) 
          ensures FIFO locking.

    (6) Read-Write Locks:

        - Synchronized does not differentiate between read and write operations i.e. 
          both block each other.

        - Lock provides ReentrantReadWriteLock where multiple readers can access 
          if no thread is writing.

    (7) Reentrant Nature:
        
        - Both synchronized and ReentrantLock are reentrant, meaning the same thread can 
          acquire the lock multiple times without getting blocked.

_______________________________________________________________________________________

*   Explain volatile keyword in detail.

>>  volatile is a keyword in Java used with instance variables in multi-threaded programming.

    It ensures visibility of changes made by one thread to other threads immediately.

    Use volatile when you want all threads to see the latest value of a variable but don’t need 
    atomicity or complex synchronization.

    Problem Without volatile:

        - In a multi-threaded environment, every thread may keep a local copy of a 
          variable for performance reasons.

        - If one thread changes the variable, other threads might not see the updated value 
          because they are reading their local cached copy — leading to data inconsistency.

    How it Works:

        - When a variable is declared as volatile its value is always read directly from 
          the main memory (RAM).

        - Its updated value is immediately written back to the main memory after modification.

        - No caching happens — every read/write is from/to the main memory.

    Example:
            
        - Without volatile, reader thread may never see updated flag.

        - With volatile, change done by writer thread is visible immediately to reader thread.

        SharedResource.class:

            ```
                class SharedResource {
                    volatile boolean flag = false;

                    void writer() {
                        flag = true; // Written to main memory directly
                    }

                    void reader() {
                        while (!flag) {  // Always reads latest value from main memory
                            // Waiting for flag to become true
                        }
                        System.out.println("Flag is true, exiting loop.");
                    }
                }
            ```

_______________________________________________________________________________________

*   Explain ThreadLocal in detail.

>>  ThreadLocal is a special class in Java (java.lang.ThreadLocal) that provides thread-local storage.

    It allows you to create variables where each thread has its own separate copy of that variable.

    No thread can see or modify another thread’s ThreadLocal variable.

    Why do we need ThreadLocal:
    
        - In multi-threaded applications sometimes, you want to avoid sharing data between threads such as 
        User session data, Transaction ID specific to a thread etc.

        - Using ThreadLocal solves this without synchronization because each thread gets its own independent copy.

    How it works:

        - Each Thread object has a private ThreadLocalMap.

        - When you call threadLocal.set(value), that value is stored inside the current thread's ThreadLocalMap.

        - When you call threadLocal.get(), value is retrieved from that current thread’s ThreadLocalMap.

    Example:

        UserContext.class:

            ```
                class UserContext {
                    private static ThreadLocal<String> userName = new ThreadLocal<>();

                    public static void setUser(String name) {
                        userName.set(name);  // Store user in current thread's ThreadLocalMap
                    }

                    public static String getUser() {
                        return userName.get();  // Retrieve user from current thread's ThreadLocalMap
                    }
                }
            ```

        Main.class:
        
            ```
                public class Main {
                    public static void main(String[] args) {
                        Runnable task1 = () -> {
                            UserContext.setUser("Alice");
                            System.out.println(Thread.currentThread().getName() + " User: " + UserContext.getUser());
                        };

                        Runnable task2 = () -> {
                            UserContext.setUser("Bob");
                            System.out.println(Thread.currentThread().getName() + " User: " + UserContext.getUser());
                        };

                        new Thread(task1, "Thread-1").start();
                        new Thread(task2, "Thread-2").start();
                    }
                }
            ```

        - Even though userName is a static variable, both threads have different copies.
        
        Output:

            ```
                Thread-1 User: Alice
                Thread-2 User: Bob
            ```
            
_______________________________________________________________________________________

*   Explain in detail Thread Starvation.

>>  Thread starvation occurs in multithreaded applications when a thread is permanently 
    or for a very long time prevented from gaining access to shared resources, because 
    other threads keep acquiring them.

    Example:

        SharedResource.class:

            ```
                class SharedResource {
                    ReentrantLock lock = new ReentrantLock();  // unfair lock by default

                    void accessResource() {
                        lock.lock();
                        try {
                            System.out.println(Thread.currentThread().getName() + " acquired the lock");
                            try { Thread.sleep(1000); } catch (InterruptedException e) {}
                        } finally {
                            lock.unlock();
                        }
                    }
                }
            ```
        
        Main.class:

            ```
                public class Main {
                    public static void main(String[] args) {
                        SharedResource resource = new SharedResource();

                        // 1 High Priority Thread - Always acquiring lock
                        Thread highPriorityThread = new Thread(() -> {
                            while (true) {
                                resource.accessResource();
                            }
                        }, "High-Priority-Thread");

                        // 1 Low Priority Thread - Rarely gets a chance
                        Thread lowPriorityThread = new Thread(() -> {
                            while (true) {
                                resource.accessResource();
                            }
                        }, "Low-Priority-Thread");

                        highPriorityThread.setPriority(Thread.MAX_PRIORITY);
                        lowPriorityThread.setPriority(Thread.MIN_PRIORITY);

                        highPriorityThread.start();
                        lowPriorityThread.start();
                    }
                }
            ```
        
        Output:

            ```
                High-Priority-Thread acquired the lock
                High-Priority-Thread acquired the lock
                ...
                ...
                ( Low-Priority-Thread hardly gets a chance! )
            ```

    Common Causes of Starvation:

        (1) Priority-based Scheduling:

            - In some systems, high-priority threads are always scheduled first and get priority 
              access to resources.

            - Low-priority threads may never get CPU time and keep waiting endlessly because 
              higher priority threads keep executing, lead to starvation.

        (2) Improper Lock Usage:    
            
            - If a thread holds a lock for a long time or keeps acquiring the same lock repeatedly 
              without releasing it soon enough, other threads get starved.

            Example:

                ```
                    synchronized (sharedResource) {
                        while(true) { 
                            // long running code or infinite loop
                        }
                    }
                ```
        
        (3) Writer Starvation in Read-Write Locks:

            - Using ReentrantReadWriteLock if too many readers acquire the lock continuously, writer 
              thread keeps waiting and Writer starvation happens.

    How to Prevent Thread Starvation:

        (1) Use Fair Locks:

            - Java provides fair locking mechanisms that grant access to threads in the order 
              they requested.

            Example:

                ```
                    ReentrantLock lock = new ReentrantLock(true);  // true = fair lock
                ```

        (2) Avoid Priority-based Scheduling (Unless Required):

            - Let the OS/Thread Scheduler handle it naturally.

            - Don't assign extreme priorities unless really necessary.

        (3) Release Locks Quickly:

            - Keep synchronized blocks small and efficient.

            - Never hold a lock for long-running tasks.

_______________________________________________________________________________________

*   What are the differences between Deadlock and Starvation ?

>>  (1) Definition:

        - Deadlock happens when two or more threads are waiting forever for each other’s 
          lock and none of them proceeds.

        - Starvation happens when a low priority thread keeps waiting because other high 
          priority threads are always acquiring the required resource.

    (2) Impact:
    
        - Due to Deadlock, no thread proceeds further and program freeze.

        - Due to Starvation, some threads (usually low priority) don’t get 
          CPU time or resource for a long time. Program still runs, but unfairly.

    (3) Resource State:
    
        - Deadlock happens when resources are locked forever. No release.

        - Starvation happens when resources are being released but low-priority threads 
          don’t get a chance to acquire them.

    (4) Prevention Techniques:
        
        - To prevent Deadlock, avoid nested Locks, Lock in same order and use tryLock() with timeout.

        - To prevent Starvation, use Fair Lock (ReentrantLock with fairness = true).

_______________________________________________________________________________________

*   Explain LiveLock in detail.

>>  Livelock is a situation in multithreading where two or more threads keep responding 
    to each other’s actions but are unable to make any progress in their execution.

    Threads are "alive" and not blocked but they are continuously changing their state 
    to avoid deadlock still no thread is able to proceed further.

    Why does Livelock happen?

        - They keep yielding or releasing resources for other threads, but because both 
          are doing the same thing, no one moves forward.

    Example:

        SharedResource.class:

            ```
                class SharedResource {
                    volatile boolean isAvailable = true;
                }
            ```
        
        Worker.class:

            ```
                class Worker implements Runnable {
                    private SharedResource resource;

                    Worker(SharedResource resource) {
                        this.resource = resource;
                    }

                    public void run() {
                        while (true) {
                            if (resource.isAvailable) {
                                System.out.println(Thread.currentThread().getName() + " doing work...");
                                resource.isAvailable = false;

                                try { Thread.sleep(100); } catch (InterruptedException e) {}

                                resource.isAvailable = true; // Being polite, releasing for other thread
                            } else {
                                // Yield CPU for other thread
                                Thread.yield();
                            }
                        }
                    }
                }
            ```
        
        Main.class:
        
            ```
                public class Main {
                    public static void main(String[] args) {
                        SharedResource resource = new SharedResource();

                        Thread t1 = new Thread(new Worker(resource), "Thread-1");
                        Thread t2 = new Thread(new Worker(resource), "Thread-2");

                        t1.start();
                        t2.start();
                    }
                }
            ```
        Output:

            ```
                Thread-1 doing work...
                Thread-2 doing work...
                Thread-1 doing work...
                Thread-2 doing work...
                .
                .
                (They keep releasing resource for each other forever but not doing meaningful work)
            ```

_______________________________________________________________________________________












